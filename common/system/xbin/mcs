#!/system/bin/sh
# Magic Charging Switch (mcs)
# Copyright (C) 2017-2018, VR25 @ xda-developers
# License: GPL v3+



modID=mcs
modData=/data/media/$modID
config=$modData/config.txt
logsDir=$modData/logs
newLog=$logsDir/${modID}_verbose_log.txt
oldLog=$logsDir/${modID}_verbose_previous_log.txt



# use Magisk's busybox
if [ "$2" != "dpath" ]; then
  [ -d /sbin/.core/busybox ] && PATH=/sbin/.core/busybox:$PATH \
    || PATH=/dev/magisk/bin:$PATH
fi



# verbose generator
mkdir -p $logsDir 2>/dev/null
if [[ $1 != debug ]]; then
  [[ -f $newLog ]] && mv $newLog $oldLog
  set -x 2>>$newLog
fi



get_prop() {
  FILE="$2"
  [ -z "$FILE" ] && FILE="$config"
  sed -n "s|^$1=||p" "$FILE" 2>/dev/null
}

set_prop() { sed -i "s|^$1=.*|$1=$2|g" "$config"; }



# find modPath
echo
modPath=/sbin/.core/img/$modID
[[ -f $modPath/module.prop ]] || modPath=/magisk/$modID
[[ -f $modPath/module.prop ]] || \
  { echo -e "(!) 找不到 modPath\n"; exit 1; }
defaultConfig=$modPath/config/${modID}
modVersion="$(get_prop versionCode $modPath/module.prop)"



# device ID
for i in ro.product.device ro.build.product; do
  model="$(getprop $i )"
  [ -n "$model" ] && break || model=generic
done
device="$(getprop ro.product.brand)_$model"



debug() {
  set +x
  echo "(i) 收集调试数据中..."
  rm $logsDir/${modID}_debug*txt 2>/dev/null
  rm /sdcard/${modID}_debug*txt 2>/dev/null

  exec 3>&1
  exec >$logsDir/${modID}_debug_log-${device}-${modVersion}-$(date +%Y%m%d%H%M%S).txt
  echo -e "$(date)\n${modID}Version=$modVersion\n\n\n"

  echo -e "### PROPS(道具) ###\n"
  getprop | grep -Ei 'product|version'
  echo -e "\n\n"

  echo -e "### /sys/class/power_supply/* ###\n"
  generate_sys_cache
  cat $modData/sys_cache
  echo -e "\n"

  echo -e "### POWER UEVENT ###\n"
  generate_sys_cache null_value
  for ueventFile in $(grep -i 'battery/uevent' $modData/sys_cache); do
    chmod +r "$ueventFile"
    if grep -i '^POWER_SUPPLY_NAME=' "$ueventFile" | grep -Eiq 'battery$|smb.*\-battery$'; then
      echo "[$ueventFile]"
      cat "$ueventFile"
      echo
    fi
  done
  echo -e "\n"

  for file in $modData/* $modData/logs/*; do
    if [[ -f $file ]] && ! echo "$file" | grep -Eq 'sys_cache|_debug_log'; then
      echo -e "### $file ###\n"
      cat "$file"
      echo -e "\n\n"
    fi
  done

  exec 1>&3 3>&-

  cp -f $logsDir/${modID}_debug*txt /sdcard/
  echo -e "\n-- 生成的文件: $( ls /sdcard/${modID}_debug*txt)\n"
  echo -e "-- 在线支持: https://forum.xda-developers.com/apps/magisk/module-magic-charging-switch-cs-v2017-9-t3668427\n"
  rm $modData/sys_cache
}



# charging loop
c_loop() {
  $(get_prop loopVerbose) || set +x
  Switch ON
  while :; do
    until [ "$(batt_level)" -ge "$1" ]; do
      clear
      echo "Charging until $1%..."
      echo "当前电池电量: $(batt_level)%"
      echo -e "$startTime\n"
      echo "(i) 按 CTRL (Vol. Down) + C 以中止."
      sleep 12
    done

    Switch OFF
    echo -e "\n(i) 已达到期望的 % ."
    end_time

    # Reset battery stats
    dumpsys batterystats --reset &>/dev/null

    echo -e "- 充电暂停.\n"
    echo "(i) 等待达到 $(lower_limit)% 后重启循环..."
    echo "- 按 CTRL (Vol. Down) + C 以中止."

    until [ "$(batt_level)" -le "$(lower_limit)" ]; do
      sleep 12
    done

    Switch ON
  done
}



check_compatibility() {
  echo "(i) 检查兼容性中..."

  # preparation
  generate_sys_cache null_value


  # test 1 -- uevent
  for ueventFile in $(grep -i 'battery/uevent' $modData/sys_cache); do
    chmod +r "$ueventFile"
    if grep -i '^POWER_SUPPLY_NAME=' "$ueventFile" | grep -Eiq 'battery$|smb.*\-battery$'; then
      set_prop uevent "$ueventFile"
      break
    fi
  done


  # test 2 -- charging switch
  if [[ -f $(uevent) ]]; then

    if ! charging; then
      echo "- 等待连接充电器..."
      $(get_prop loopVerbose) || set +x
      until charging; do sleep 5; done
      $(get_prop loopVerbose) || set -x 2>>$newLog
      echo "-- 检测到充电器"
      echo "- 请稍候..."
    fi

    for ctrlFile in $(grep -Ev '#|^$' $modPath/config/switches); do
      for ctrlFile_ in $(grep "$ctrlFile" $modData/sys_cache); do
        if [[ -f "$ctrlFile_" ]]; then
          chmod +r "$ctrlFile_"
          set_switch "$ctrlFile_"
          [ "$?" = "3" ] && continue
          if [ -n "$(get_prop offKey)" ]; then
            Switch OFF
            sleep 2
            charging || break
          fi
        fi
      done
      if ! charging; then
        Switch ON
        sleep 2
        charging && break || set_switch
      else
        [ -n "$(get_prop onKey)" ] && Switch ON
        set_switch
      fi
    done
  fi


  # verdict
  if [[ ! -f $(Switch) ]]; then
    echo -e "- (!) 不支持的设备.\n-- 您的内核可能不支持高级充电控制.\n"
    debug
  else
    echo -e "- 恭喜，您的设备受支持!\n"
    rm $modData/sys_cache
    sleep 2
  fi
}


exit1() {
  echo "(!) $*: 无效的选项/参数"
  echo -e "- 输入并运行 \"${modID} -h\" 以获取帮助\n"
  exit 1
}


set_switch() {
  if [ -n "$1" ]; then
    set_prop switch "$1"
    case $(cat "$(Switch)") in
      1) set_prop onKey 1; set_prop offKey 0;;
      0) set_prop onKey 0; set_prop offKey 1;;
      on) set_prop onKey on; set_prop offKey off;;
      off) set_prop onKey off; set_prop offKey on;;
      100) set_prop onKey 100; set_prop offKey 3;;
      true) set_prop onKey true; set_prop offKey false;;
      false) set_prop onKey false; set_prop offKey true;;
      enable) set_prop onKey enable; set_prop offKey disable;;
      disable) set_prop onKey disable; set_prop offKey enable;;
      enabled) set_prop onKey enabled; set_prop offKey disabled;;
      disabled) set_prop onKey disabled; set_prop offKey enabled;;
      Charging) set_prop onKey Charging; set_prop offKey Discharging;;
      *) return 3;;
    esac 2>/dev/null
  else
    # reset values back to null
    set_prop switch
    set_prop onKey
    set_prop offKey
  fi
}


Switch() {
  if [ -z "$1" ]; then
    get_prop switch
  else
    chmod +rw "$(Switch)"
    case $1 in
      ON) echo "$(get_prop onKey)" >"$(Switch)";;
      OFF) echo "$(get_prop offKey)" >"$(Switch)";;
    esac
  fi
}


OFF_time() {
  if $invertOff; then Switch ON; else Switch OFF; fi
  if [ -n "$1" ]; then
    if echo "$1" | grep -q '[a-z]'; then

      if $invertOff; then
        echo "(i) Charging enabled for $1."
      else
        echo "(i) Charging disabled for $1."
      fi
      start_time

      if echo "$1" | grep -q 'm'; then
        sleep $(( 60 * $(echo $1 | sed 's/m//') ))
      elif echo "$1" | grep -q 'h'; then
        sleep $(( 3600 * $(echo $1 | sed 's/h//') ))
      else exit1
      fi
    elif ! echo "$1" | grep -q '[a-z]' \
      && echo "$1" | grep -q '[0-9]'; then

      if $invertOff; then
        echo "(i) Charging enabled for $1s."
      else
        echo "(i) Charging disabled for $1s."
      fi
      start_time
      sleep $1
    fi
    echo -e "\n(i) 时间到了."

    if $invertOff; then
      Switch OFF
      echo "- 充电禁用"
    else
      Switch ON
      echo "- 充电重新启用"
    fi
    end_time

  else
    if $invertOff; then
      echo "(i) 充电启用"
    else
      echo "(i) 充电禁用"
    fi
  fi
  echo
}


OFF_percent() {
  if $invertOff; then
    Switch ON
    echo "(i) Charging enabled until $1."
  else
    Switch OFF
    echo "(i) Charging disabled until $1."
  fi
  start_time

  echo
  until [ "$(batt_level)" -ge "$(echo $1 | sed 's/%//')" ]; do
    sleep 12
  done
  echo "(i) 达到期望的 % ."

  if $invertOff; then
    Switch OFF
    echo "- 充电禁用"
  else
    Switch ON
    echo "- 充电重新启用"
  fi
  end_time
  echo
}


auto_run() { get_prop autoRun; }

batt_level() { get_prop POWER_SUPPLY_CAPACITY "$(uevent)"; }

charging() { grep -iqs '=charging$' "$(uevent)"; }

end_time() { echo "- End time: $(date)"; }

higher_limit() { get_prop higherLimit; }

lower_limit() { get_prop lowerLimit; }

pause_daemon() { get_prop pauseDaemon; }

start_time() { echo "- Start time: $(date)"; }

uevent() { get_prop uevent; }


update_cfg() {
  if [ -z "$1" ]; then
    set_prop higherLimit 90
    set_prop lowerLimit 80
  else
    if [ -n "$2" ]; then
      set_prop higherLimit "$1"
      set_prop lowerLimit "$2"
    else
      set_prop higherLimit "$1"
      set_prop lowerLimit 80
    fi
  fi
}


generate_sys_cache() {
  for e in /sys/class/power_supply/*; do
    for file in $(find "$(readlink -f "$e")" -type f 2>/dev/null); do
      chmod +r "$file"
      if [ "$1" = "null_value" ]; then
        echo "$file"
      else
        echo "$file [$(cat "$file" 2>/dev/null | head -n1)]"
      fi
    done
    echo
  done >$modData/sys_cache
}


# self-check
if ! echo "$1 $2" | grep -Eq '\-x|\-h|\-r|debug' &>/dev/null; then
  if [[ ! -f $(Switch) || ! -f $config ]]; then
    cp $defaultConfig $config
    check_compatibility
  fi
  if ! $(auto_run) || $(pause_daemon); then
    startTime="$(start_time)"
  fi
  invertOff=false
fi



# options menu
case $1 in

  # manually set a charging switch
  -x)
    echo "(i) 请稍候..."
    generate_sys_cache null_value
    for ueventFile in $(grep -i 'battery/uevent' $modData/sys_cache); do
      chmod +r "$ueventFile"
      if grep -i '^POWER_SUPPLY_NAME=' "$ueventFile" | grep -Eiq 'battery$|smb.*\-battery$'; then
        set_prop uevent "$ueventFile"
        break
      fi
    done

    if [[ ! -f $(uevent) ]]; then
      echo -e "(!) 不支持的设备\n"
      debug
    fi

    if [ -n "$2" ]; then
      set_switch "$2"
      if [ -n "$4" ]; then
        set_prop onKey $3
        set_prop offKey $4
      fi
      echo -e "- 充电开关设置成功.\n"

    else
      echo "- 从 ${device} 获取已知的控制文件..."
      : >$modData/.${modID}x
      count=0

      if ! charging; then
        echo "-- 等待连接充电器..."
        until charging; do sleep 5; done
        echo "--- 检测到充电器"
        echo "-- 请等候..."
      fi

      echo
      [[ -f $(Switch) ]] || set_switch dummy_switch

      for ctrlFile in $(grep -Ev '#|^$' $modPath/config/switches); do
        for ctrlFile_ in $(grep "$ctrlFile" $modData/sys_cache | grep -v "$(Switch)"); do
          if [[ -f $ctrlFile_ ]]; then
            ((count++))
            echo -e "[$count] $ctrlFile_\n" >>$modData/.${modID}x
          fi
        done
      done

      if grep -q '[a-z]' $modData/.${modID}x; then
        cat $modData/.${modID}x
        echo "(i) 选一个号码..."
        read Input
        if [ -n "$Input" ]; then
          set_switch "$(grep "\[${Input}\] " $modData/.${modID}x | awk '{print $2}')"
          echo -e "\n(i) 新开关设置成功.\n"
        fi
      else
        echo -e "\n(i) 没有找到其他(额外)的开关\n"
      fi

    fi
    rm $modData/.${modID}x $modData/sys_cache 2>/dev/null
    [[ -f $(Switch) ]] || set_switch
    ;;


  debug) debug;;


  # toggle daemon state
  -s)
    if [ "$2" = "stop" ]; then
      set_prop autoRun false
      set_prop pauseDaemon false
      rm $modData/.daemon 2>/dev/null
      echo "(i) ${modID} 守护程序已停止."
    elif [ "$2" = "start" ]; then
      set_prop autoRun true
      set_prop pauseDaemon false
      (${modID} daemon) &
      echo "(i) ${modID} 守护程序启动."
      echo "- You may close this window."
    else
      if $(pause_daemon); then
        set_prop pauseDaemon false
        Switch ON
        echo "(i) ${modID} 守护程序已恢复."
      else
        set_prop pauseDaemon true
        echo "(i) ${modID} 守护程序已暂停."
      fi
    fi
    echo
    ;;


  # toggle extensive (loops) verbose
  # don't let this be enabled forever
    -v)
    if $(get_prop loopVerbose); then
      set_prop loopVerbose false
      echo -e "(i) Loop verbose 禁用"
    else
      set_prop loopVerbose true
      echo -e "(i) Loop verbose 启用"
    fi
    echo
    ;;


  # keep/maintain battery power at a constant level
  # $2=%value
  -k)
    $(get_prop loopVerbose) || set +x
    if $(auto_run) && ! $(pause_daemon) && [ -f $modData/.daemon ]; then
      set_prop pauseDaemon true
      echo "(i) ${modID} 守护进程已暂停."
      echo -e "- 重启或运行代码 \"${modID} -s\" 以恢复.\n"
    fi

    echo "维护 $2% 中..."
    echo "(i) 按 CTRL (音量-) + C 以中止"
    Switch ON

    while :; do

      until [ "$(batt_level)" -ge "$2" ] || ! charging; do
        sleep 12
      done

      [ "$(batt_level)" -ge "$2" ] && Switch OFF

      until [ "$(batt_level)" -le "$2" ] || charging; do
        sleep 12
      done

      [ "$(batt_level)" -le "$2" ] && Switch ON

    done
    ;;


  # reset battery stats on demand
  -b)
    dumpsys batterystats --reset
    echo
    ;;



  # reset settings
  -r)
    cp $defaultConfig $config \
      && echo -e "(i) 设置重置成功.\n" \
      || { echo -e "(!) 设置重置失败.\n"; exit 1; }
    ;;



  daemon)

    # exit if daemon is already running or override 'stoped' state
    if [ "$2" != "dpath" ]; then
      if $(auto_run) && [ -f $modData/.daemon ]; then
        echo -e "(i) ${modID} 守护程序已在运行中.\n"
        exit 0
      fi
      set_prop autoRun true
    fi

    if $(auto_run); then
      set_prop pauseDaemon false
      Switch ON
      # create lock file
      touch $modData/.daemon
    else
      exit 0
    fi

    echo "(i) ${modID} 守护程序启动."
    echo -e "- 您可以关闭此窗口.\n"
    $(get_prop loopVerbose) || set +x

    # remove lock file on exit/interrupt
    trap 'exitC=$?; \
      rm $modData/.daemon 2>/dev/null; \
      exit $exitC' \
      0 2

    while $(auto_run) && [ -f $modData/.daemon ]; do
      $(pause_daemon) && sleep 12
      until $(pause_daemon); do
        if [ "$(batt_level)" -le "$(lower_limit)" ] \
        && [ "$(get_prop offKey)" = "$(cat "$(Switch)")" ]; then
          Switch ON
        fi
        sleep 12
        if [ "$(batt_level)" -ge "$(higher_limit)" ] \
        && [ "$(get_prop onKey)" = "$(cat "$(Switch)")" ]; then
          Switch OFF
          dumpsys batterystats --reset &>/dev/null
        fi
        sleep 12
      done
    done
    ;;



  # help
  --help|-h|help)
    set +x
    cat <<EOD
Magic Charging Switch (mcs)汉化版

先进的电池充电控制器

语法:
mcs [-b] [-h] [-i] [-r] [-v] [debug] [-k %LEVEL] [%PAUSE %RESUME] [%PAUSE] [-m/t %PAUSE %RESUME] [-s start/stop] [-d/e %/TIMEOUT] [-x /path/to/switch onValue offValue]

-b --> 重置电池统计数据(不一定能在所有设备上工作)

-i --> 显示配置和调试和电源信息

-r --> 重置设置

-s --> 暂停/恢复, 开始/停止守护进程

-v --> 切换广泛（循环）详细资料

-x --> 从数据库中选择一个充电开关

debug --> 收集调试数据并保存到 $logsDir/mcs_debug_log-\$device-\$csVER-\$DATE.txt

-k %LEVEL --> 保持/维持电池电量恒定在 %LEVEL（暂停MCS服务）

[no args] --> 使用默认/上一个设置运行MCS

-h/--help/help --> 使用说明

%PAUSE %RESUME --> 当达到%PAUSE值(默认90)时暂停充电; 如果电量下降到%RESUME(默认80)则恢复。 这是初始设置命令。如果自动运行为关闭，则命令按原样运行;否则，新设置将被mcs守护程序保存并自动获取

-m/-t %PAUSE %RESUME --> 生成自动化配置文件 (-m:MacroDroid配置; -t:Tasker配置 -- 选择一个)

-d/e [%/TIMEOUT (可选)] --> 按需暂停/启用充电(暂停MCS服务)

-x /path/to/switch ON_key OFF_key -- > 手动设置充电开关;如果值与以下组之一匹配，则按原样或按相反顺序匹配 - 您不必指定它们: 1/0, enable/disable, enabled/disabled, true/false, on/off, 100/3, Charging/Discharging

使用示例/提示:

mcs 90 充到 90% 后断电，如果数据线不拔插掉电到 80%(默认值) 又开始充电
mcs 80 20 充到 80% 后断电，如果数据线不拔插掉电到 20% 又开始充电
mcs -d 马上停止充电
mcs -e 马上开始充电
mcs -d/-e 1/1m/1h 1秒/1分钟/1小时后 断开/开始充电
mcs -d/-e 50% 电量到 50% 时断开/开始充电
mcs -s 启动控制/关闭控制

mcs -e 120 && mcs -d 30m && mcs -e 1h
充两分钟电(120s)，断开半小时，又开始充电一小时后断电
mcs -e 30m && mcs -d 30m && mcs -e 90%
充半小时，然后断开半小时后一直充电到 90%
mcs -e 50% && mcs -d 5h && mcs -e 80% && mcs -d 30m && mcs -e 90%
充电到 50% 然后断电 5 小时，然后充到 80%，断开半小时，又充到 90%

建议:
理想情况下，保持在在40%-60%之间，寿命最长，20%-80%较为平均，10%-90%-合理
为方便起见，请使用 mcs 90 80 或 mcs 80 70，又方便又完美达到平衡。
如果您希望最长的电池寿命，使用mcs 42 41或mcs -k 42(最适合长期使用 -- i.e., navigation).
EOD
  echo
  ;;


  # disable charging on demand
    # $2=#% or timeout
  -d)
    if $(auto_run) && ! $(pause_daemon) && [ -f $modData/.daemon ]; then
      set_prop pauseDaemon true
      echo -e "(i) ${modID} 已暂停.\n"
    fi

    if [ -n "$2" ]; then
      case $2 in
        *[0-9]%) OFF_percent $2;;
        *) OFF_time $2;;
      esac
    else OFF_time; fi

    if $(auto_run) && $(pause_daemon); then
      echo -e "(i) 重启或运行代码 \"${modID} -s\" 以恢复 ${modID} 守护程序.\n"
    fi
    ;;


  # enable charging on demand
  # $2=#% or timeout
  -e)
    if $(auto_run) && ! $(pause_daemon) && [ -f $modData/.daemon ]; then
      set_prop pauseDaemon true
      echo "(i) ${modID} 守护程序已暂停.\n"
    fi

    invertOff=true
    if [ -n "$2" ]; then
      case $2 in
        *[0-9]%) OFF_percent $2;;
        *) OFF_time $2;;
      esac
    else OFF_time; fi

    if $(auto_run) && $(pause_daemon); then
      echo -e "(i) 重启或运行代码 \"${modID} -s\" 以恢复 ${modID} 守护程序.\n"
    fi
    ;;


  # info
  -i)
    echo -e "POWER SUPPLY INFO\n"
    sed 's/^/ /' "$(uevent)"
    echo -e '\n\n'
    sed 's/^# //;/^[a-z]/s/^/  /;s/^</ </' $config
    echo -e '\n\n'
    echo "DEBUGGING INFO\n"
    set | sed 's/^/ /'
    echo
    ;;


  # run with previous settings
  # or apply default charging limits (higherLimit=90 lowerLimit=80)
  "")
    if $(auto_run) && ! $(pause_daemon) && [ -f $modData/.daemon ]; then
      echo -e "(i) ${modID} 守护进程已经在运行中.\n"
      exit 0
    fi

    c_loop $(higher_limit)
    ;;


  # generate MacroDroid & Tasker automation configs
  -m|-t)
    case $1 in
      -m)
        echo "(i) 配置文件生成 /sdcard/MacroDroid/${modID}.category..."
        mDir=/sdcard/MacroDroid
        [[ -d $mDir ]] || mkdir $mDir
        cp $modPath/config/macrodroid $mDir/${modID}.category
        cd $mDir
        sed -i "s/:90/:$2/; s/:11/:$3/" ${modID}.category
        ;;

      -t)
        echo "(i) 配置文件生成 /sdcard/Tasker/projects/${modID}.prj.xml..."
        tDir=/sdcard/Tasker/projects
        [[ -d $tDir ]] || mkdir -p $tDir
        cp $modPath/config/tasker $tDir/${modID}.prj.xml
        cd $tDir
        sed -i "/<Int sr=\"arg0\" val=\"90\"\/>/s/90/$2/" ${modID}.prj.xml
        sed -i "/<rhs>90<\/rhs>/s/90/$2/" ${modID}.prj.xml
        sed -i "/<Int sr=\"arg1\" val=\"10\"\/>/s/10/$3/" ${modID}.prj.xml
        sed -i "/<rhs>10<\/rhs>/s/10/$3/" ${modID}.prj.xml
        ;;

      *) exit1;;
    esac

    echo -e "- 结束\n"
    ;;


  # initial setup
  # $1=higherLimit (i.e., 90)
  # $2=lowerLimit (i.e., 80)
  [0-9]*)
    update_cfg $1 $2
    echo "(i) 已保存新的设置"
    sleep 1

    if $(auto_run) && ! $(pause_daemon) && [ -f $modData/.daemon ]; then
      echo "- ${modID} 守护进程已经在运行."
      echo -e "-- 以新的设置工作中\n"
      Switch ON
      exit 0
    fi

    c_loop $1
    ;;


  *) exit1;;
esac

exit 0
